C51 COMPILER V8.06   MAIN                                                                  05/02/2008 22:28:52 PAGE 1   


C51 COMPILER V8.06, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil8\C51\Bin\C51.exe main.c DB OE LARGE

line level    source

   1          //------------------------------------------------------------------------------
   2          // main.c
   3          //------------------------------------------------------------------------------
   4          // Copyright (C) 2005 Silicon Laboratories, Inc.
   5          //
   6          // Date: 04/13/08 06:24:26
   7          // Target: C8051F34x 
   8          //
   9          // Description:
  10          //    This file contains the main routine, MCU initialization code, and
  11          //    callback functions used by the TCP/IP Library.
  12          //
  13          // Generated by TCP/IP Configuration Wizard Version 3.23
  14          //
  15          #include "mn_userconst.h"                      // TCP/IP Library Constants
  16          #include "mn_stackconst.h"                     // TCP/IP Library Constants
  17          #include "mn_errs.h"                           // Library Error Codes
  18          #include "mn_defs.h"                           // Library Type definitions
  19          #include "mn_funcs.h"                          // Library Function Prototypes
  20          #include "VFILE_DIR\index.h"
  21          #include <c8051F340.h>                         // Device-specific SFR Definitions
  22          #include <stdio.h>
  23          #include <string.h>
  24          #include "soft_i2c.h"
  25          
  26          //------------------------------------------------------------------------------
  27          // Function Prototypes
  28          //------------------------------------------------------------------------------
  29          
  30          
  31          
  32          // Initialization Routines
  33          void PORT_Init (void);
  34          void SYSCLK_Init (void);
  35          void EMIF_Init(void);
  36          int establish_network_connection();
  37          //void get_data(PSOCKET_INFO socket_ptr);
  38          void wol(PSOCKET_INFO socket_ptr);
  39          void set(PSOCKET_INFO socket_ptr);
  40          void get_hora(PSOCKET_INFO socket_ptr);
  41          
  42          
  43          //Funciones de fecha
  44          struct fecha
  45          {
  46                  int hora, min, sec;
  47                  char valid;
  48          //      char day, date, month, year;
  49          };
  50          
  51          struct fecha gethora_web(byte ip[4]);
  52          struct fecha gethora_i2c();
  53          void sethora_i2c(struct fecha f);
  54          
  55          sbit SW1 = P1^1;
C51 COMPILER V8.06   MAIN                                                                  05/02/2008 22:28:52 PAGE 2   

  56          sbit SW2 = P1^2;
  57          sbit LED0 = P1^3;
  58          sbit LED1 = P1^4;
  59          
  60          sbit RELE = P0^1;
  61          
  62          sbit TRIAC1 = P0^7;
  63          sbit TRIAC2 = P0^4;
  64          sbit TRIAC3 = P0^2;
  65          sbit TRIAC4 = P0^0;
  66          //sbit TRIAC5 = P0^3;
  67          sbit TRIAC6 = P0^5;
  68          
  69          sbit DETFASE = P0^6;
  70          
  71          sfr16  TMR2RL      =  0xCA;
  72          
  73          
  74          
  75          struct fecha now={23,00,10};
  76          
  77          int regtriac[4]={100,100,100,100};
  78          int st_triac[6]={0,0,0,0,0,0};
  79          int low=-24, high=-20;
  80          bit st_rele=0;
  81          
  82          bit power_mising=0;
  83          
  84          xdata byte html_buffer[256];
  85          byte dest_mac[6]={0x00,0x11,0x2F,0x91,0xE3,0x74};       // dir mac del wol
  86          byte dest_ip[4]={192,168,1,1};                                          // ip del servidor web para hora
  87          //-----------------------------------------------------------------------------
  88          // Main Routine
  89          //-----------------------------------------------------------------------------
  90          
  91          char get_celsius()
  92          {
  93   1              return read_register(TC74A0,0);
  94   1      }
  95          
  96          void main(void)
  97          {
  98   1         int retval;
  99   1              char c,d;
 100   1      
 101   1         // Disable watchdog timer
 102   1         PCA0MD = 0x00;
 103   1      
 104   1         // Initialize the MCU
 105   1         PORT_Init();
 106   1         SYSCLK_Init();
 107   1         EMIF_Init();
 108   1      
 109   1      
 110   1              TMR2CN    = 0x04;
 111   1              IE        |= 0xA0;
 112   1              TMR2RL=-100*4;
 113   1              IP|=0x20;
 114   1      
 115   1         while(1)
 116   1         {
 117   2            // Initialize the TCP/IP stack. 
C51 COMPILER V8.06   MAIN                                                                  05/02/2008 22:28:52 PAGE 3   

 118   2            if (mn_init() < 0)
 119   2            {
 120   3               // If code execution enters this while(1) loop, the stack failed to initialize.
 121   3               // Verify that all boards are connected and powered properly.
 122   3               while(1);
 123   3            }
 124   2      
 125   2            // Connect to the network
 126   2            establish_network_connection();
 127   2              
 128   2                
 129   2                now=gethora_i2c();
 130   2      
 131   2            // Add web page to virtual file system.
 132   2            // The main page MUST be called index.htm or index.html.
 133   2            mn_vf_set_entry((byte *)"index.html", INDEX_SIZE, index_html, VF_PTYPE_FLASH);
 134   2      
 135   2                // Add CGI Script to Virtual File System
 136   2                mn_pf_set_entry((byte*)"wol",wol);
 137   2                mn_pf_set_entry((byte*)"get_hora",get_hora);
 138   2                mn_pf_set_entry((byte*)"set",set);
 139   2      
 140   2            // Start the Application Layer Services
 141   2            // If this routine exits, check the return value for an error code.
 142   2            retval = mn_server();
 143   2      
 144   2         }
 145   1      }
*** WARNING C280 IN LINE 99 OF MAIN.C: 'c': unreferenced local variable
*** WARNING C280 IN LINE 99 OF MAIN.C: 'd': unreferenced local variable
 146          
 147          void sethora_i2c(struct fecha f)
 148          {
 149   1              char s,m,h;
 150   1              s=(f.sec/10)<<4|(f.sec%10);
 151   1              m=(f.min/10)<<4|(f.min%10);
 152   1              h=(f.hora/10)*16|(f.hora%10);
 153   1              write_register(DS1307,0,s);
 154   1              write_register(DS1307,1,m);
 155   1              write_register(DS1307,2,h);
 156   1      }
 157          
 158          struct fecha gethora_i2c()
 159          {
 160   1              struct fecha f;
 161   1              char h,m,s;
 162   1              s=read_register(DS1307,0);
 163   1              m=read_register(DS1307,1);
 164   1              h=read_register(DS1307,2);
 165   1              f.sec= (s&0xf)+(s>>4)*10;
 166   1              f.min= (m&0xf)+(m>>4)*10;
 167   1              f.hora= (h&0xf)+(h>>4)*10;
 168   1              return f;
 169   1      
 170   1      
 171   1      }
 172          void Timer2_handler() interrupt 5
 173          {
 174   1         static int tics=0;
 175   1         static bit old_fase=0;
 176   1         static int cruces=0;
 177   1         
C51 COMPILER V8.06   MAIN                                                                  05/02/2008 22:28:52 PAGE 4   

 178   1         if(old_fase!=DETFASE)
 179   1         {
 180   2                      old_fase=DETFASE;
 181   2                      if(DETFASE==0)
 182   2                              tics=low;
 183   2                      else
 184   2                              tics=high;
 185   2                      cruces++;
 186   2         }
 187   1         else
 188   1                      tics++;
 189   1      
 190   1      RELE=st_rele;
 191   1      TRIAC6=st_triac[5];
 192   1      //TRIAC5=st_triac[4];
 193   1      
 194   1      if(!st_triac[3])
 195   1              TRIAC4=0;
 196   1      else if(regtriac[3]>100)
 197   1              TRIAC4=1;
 198   1      else if(tics==100-regtriac[3])
 199   1              TRIAC4=1;
 200   1      else
 201   1              TRIAC4=0;
 202   1      
 203   1      if(!st_triac[2])
 204   1              TRIAC3=0;
 205   1      else if(regtriac[2]>100)
 206   1              TRIAC3=1;
 207   1      else if(tics==100-regtriac[2])
 208   1              TRIAC3=1;
 209   1      else
 210   1              TRIAC3=0;
 211   1      
 212   1      if(!st_triac[1])
 213   1              TRIAC2=0;
 214   1      else if(regtriac[1]>100)
 215   1              TRIAC2=1;
 216   1      else if(tics==100-regtriac[1])
 217   1              TRIAC2=1;
 218   1      else
 219   1              TRIAC2=0;
 220   1      
 221   1      if(!st_triac[0])
 222   1              TRIAC1=0;
 223   1      else if(regtriac[0]>100)
 224   1              TRIAC1=1;
 225   1      else if(tics==100-regtriac[0])
 226   1              TRIAC1=1;
 227   1      else
 228   1              TRIAC1=0;
 229   1      
 230   1      
 231   1      
 232   1      
 233   1      if(cruces==100||tics>10019)
 234   1              {
 235   2              if(tics>10019)
 236   2                      {
 237   3                      power_mising=1;
 238   3                      tics=0;
 239   3                      }
C51 COMPILER V8.06   MAIN                                                                  05/02/2008 22:28:52 PAGE 5   

 240   2              else
 241   2                      {
 242   3                      power_mising=0;
 243   3                      cruces=0;
 244   3                      }
 245   2              /*
 246   2              now.sec++;      
 247   2              if(now.sec>=60)
 248   2                      {now.sec=0;now.min++;}
 249   2              if(now.min>=60)
 250   2                      {now.min=0;now.hora++;}
 251   2              if(now.hora>=24)
 252   2                      {now.hora=0;}
 253   2              */
 254   2              }
 255   1      
 256   1         TF2H=0;
 257   1      
 258   1      }
 259          
 260          void wakeup(byte mac[6])
 261          {
 262   1              byte dest_ip[4]={255,255,255,255};
 263   1                      byte magic_pkg[102]={0xff,0xff,0xff,0xff,0xff,0xff};
 264   1                       SCHAR rafa;
 265   1      
 266   1                      int i;
 267   1                      for(i=0;i<16*6;i++)
 268   1                              magic_pkg[i+6]=mac[i%6];
 269   1           
 270   1                rafa=mn_open(dest_ip, 7890, 80,NO_OPEN, PROTO_UDP, STD_TYPE,html_buffer,256);
 271   1                mn_send(rafa, magic_pkg,102);
 272   1                mn_close(rafa);
 273   1      }
 274          
 275          struct fecha gethora_web(byte dest_ip[4])
 276          {
 277   1          char qry[]="GET / HTTP1.1\r\n\r\n";
 278   1              int status;
 279   1              int pos=0,i;
 280   1              SCHAR rafa;
 281   1              struct fecha f;
 282   1              
 283   1              f.valid=0;
 284   1              for(i=0;i<256;i++)html_buffer[i]=0;
 285   1              
 286   1              rafa=mn_open(dest_ip, 1234, 80,ACTIVE_OPEN, PROTO_TCP, STD_TYPE,html_buffer,256);
 287   1              mn_send(rafa, qry,strlen(qry));
 288   1              status=mn_recv_wait(rafa, html_buffer,256,20000);
 289   1              mn_close(rafa);
 290   1              for(pos=0;html_buffer[pos]!=0;pos++)
 291   1                      if(!strncmp(&html_buffer[pos],"GMT",3))
 292   1                              break;
 293   1      
 294   1              if(html_buffer[pos]!=0)
 295   1                      {
 296   2                      sscanf(&html_buffer[pos-9],"%d:%d:%d",&f.hora,&f.min,&f.sec);
 297   2                      f.valid=1;              
 298   2                      }
 299   1              return f;
 300   1              
 301   1      
C51 COMPILER V8.06   MAIN                                                                  05/02/2008 22:28:52 PAGE 6   

 302   1      }
 303          byte hex2dec(byte c)
 304          {
 305   1              if(c>='0'&&c<='9')
 306   1                      return c-'0';
 307   1              else if(c>='a'&&c<='f')
 308   1                      return c-'a'+0xa;
 309   1              else
 310   1                      return c-'A'+0xa;
 311   1      }
 312          
 313          
 314          
 315          SCHAR callback_app_server_idle(PSOCKET_INFO *psocket_ptr)
 316          {
 317   1      
 318   1         // Put your code here.
 319   1      
 320   1         // If the link goes invalid, exit mn_server().
 321   1         if(link_lost)
 322   1            return (NEED_TO_EXIT);
 323   1              if(!SW1)
 324   1                      {
 325   2                      now=gethora_web(dest_ip);
 326   2                      if(now.valid)
 327   2                              sethora_i2c(now);
 328   2      
 329   2                      }
 330   1                      //wakeup(dest_mac);
 331   1         now=gethora_i2c();
 332   1      
 333   1         psocket_ptr = psocket_ptr; // This statment prevents compiler warning.
 334   1         return (0);
 335   1      }
 336          
 337          void wol(PSOCKET_INFO socket_ptr)
 338          {
 339   1              // Insert application code here.
 340   1      
 341   1              byte msg_buff1[52];
 342   1              int status1;
 343   1              byte mac[6];
 344   1              int i,j;
 345   1      
 346   1              status1 = mn_http_find_value (BODYptr,(byte*)"mac", msg_buff1);
 347   1      
 348   1              if(status1)
 349   1              {
 350   2                      // Write the HTML code to a buffer.
 351   2                      //sscanf( msg_buff1, "%x:%x:%x:%x:%x:%x",&mac[0],&mac[1],&mac[2],&mac[3],&mac[4],&mac[5]);
 352   2                      for(i=0,j=0;i<6;i++)
 353   2                      {
 354   3                              mac[i]=hex2dec(msg_buff1[j])<<4;
 355   3                              mac[i]|=hex2dec(msg_buff1[j+1]);
 356   3                              if(msg_buff1[j+2]==':')
 357   3                                      j+=3;
 358   3                              else
 359   3                                      j+=2;
 360   3                      }
 361   2      
 362   2                      
 363   2                      wakeup(mac);
C51 COMPILER V8.06   MAIN                                                                  05/02/2008 22:28:52 PAGE 7   

 364   2                      // Fill the socket with data to send.
 365   2                      sprintf(html_buffer, "<HTML>OK</HTML>");
 366   2                      socket_ptr->send_ptr = html_buffer;
 367   2                      socket_ptr->send_len = strlen(html_buffer);
 368   2                      // Return from the CGI script
 369   2                      return;
 370   2              }
 371   1      
 372   1      }
 373          
 374          // Definition:
 375          /*
 376          void get_data(PSOCKET_INFO socket_ptr)
 377          {
 378                  // Insert application code here.
 379          
 380                  byte msg_buff1[52];
 381                  byte msg_buff2[52];
 382                  int status1;
 383                  static int ambient_light=0;
 384          
 385          
 386          
 387                  // Search for the “type” field and store the
 388                  // result in <msg_buff1>.
 389                  status1 = mn_http_find_value (BODYptr,(byte*)"type", msg_buff1);
 390          
 391                  // Search for the “setbgcolor” field
 392                  // and store the result in <msg_buff2>.
 393                  //status2 = mn_http_find_value (BODYptr,(byte*)"setbgcolor",msg_buff2);
 394          
 395                  // Check status1 and status2 to determine if
 396                  // msg_buff1 and msg_buff2 are valid.
 397                  if(status1)
 398                  {
 399                          // Write the HTML code to a buffer.
 400                          sprintf( html_buffer, "<HTML>%i</HTML>",ambient_light++);
 401          
 402                          // Fill the socket with data to send.
 403                          socket_ptr->send_ptr = html_buffer;
 404                          socket_ptr->send_len = strlen(html_buffer);
 405                          // Return from the CGI script
 406                          return;
 407                  }
 408          
 409          }
 410          */
 411          void set(PSOCKET_INFO socket_ptr)
 412          {
 413   1              // Insert application code here.
 414   1              char *sets[]={"time","triac1","triac2","triac3","triac4","triac5","triac6","rele","low","high"};
 415   1              const int maxsets=10;
 416   1              int i;
 417   1              byte msg_buff1[52];
 418   1      
 419   1              int status1, status2;
 420   1      
 421   1              status2=0;
 422   1      
 423   1              for(i=0;i<maxsets;i++)
 424   1              {
 425   2                      // Search for the “type” field and store the
C51 COMPILER V8.06   MAIN                                                                  05/02/2008 22:28:52 PAGE 8   

 426   2                      // result in <msg_buff1>.
 427   2                      status1 = mn_http_find_value (BODYptr,(byte*)sets[i], msg_buff1);
 428   2      
 429   2                      // Check status1 and status2 to determine if
 430   2                      // msg_buff1 and msg_buff2 are valid.
 431   2                if(status1)
 432   2                {
 433   3                      if(i==0)
 434   3                      {
 435   4                              sscanf( msg_buff1, "%d:%d:%d",&now.hora,&now.min,&now.sec);
 436   4                      }
 437   3                      else if(i==7)
 438   3                      {
 439   4                              if(!strcmp(msg_buff1,"on"))
 440   4                                      st_rele=1;
 441   4                              else if(!strcmp(msg_buff1,"off"))
 442   4                                      st_rele=0;
 443   4                      }
 444   3                      else if(i==8)
 445   3                      {
 446   4                              sscanf(msg_buff1,"%d",&low);
 447   4                      }
 448   3                      else if(i==9)
 449   3                      {
 450   4                              sscanf(msg_buff1,"%d",&high);
 451   4                      }
 452   3                      else
 453   3                      {
 454   4                              int j=i-1;
 455   4                              if(!strcmp(msg_buff1,"on"))
 456   4                                      st_triac[j]=1;
 457   4                              else if(!strcmp(msg_buff1,"off"))
 458   4                                      st_triac[j]=0;
 459   4                              else if (j<4)
 460   4                                      {
 461   5                                      int tmp;
 462   5                                      sscanf(msg_buff1,"%d",&tmp);
 463   5                                      regtriac[j]=tmp;
 464   5                                      st_triac[j]=1;
 465   5                                      }
 466   4                      }
 467   3                      status2=1;
 468   3                 }
 469   2              }
 470   1      
 471   1              if(status2)
 472   1              {
 473   2                      
 474   2                      // Fill the socket with data to send.
 475   2                      sprintf(html_buffer, "<HTML>OK</HTML>");
 476   2                      socket_ptr->send_ptr = html_buffer;
 477   2                      socket_ptr->send_len = strlen(html_buffer);
 478   2                      // Return from the CGI script
 479   2                      return;
 480   2              }
 481   1      
 482   1      }
 483          void get_hora(PSOCKET_INFO socket_ptr)
 484          {
 485   1              // Insert application code here.
 486   1      
 487   1              int temp=get_celsius();
C51 COMPILER V8.06   MAIN                                                                  05/02/2008 22:28:52 PAGE 9   

 488   1              // Write the HTML code to a buffer.
 489   1              sprintf( html_buffer, "<HTML><meta http-equiv=\"refresh\" content=\"1\">%2.2d:%2.2d:%2.2d   Temperature: 
             -%d ºC\tPower: %s</HTML>",now.hora,now.min,now.sec,temp,(power_mising?"OFF":"ON"));
 490   1      
 491   1              // Fill the socket with data to send.
 492   1              socket_ptr->send_ptr = html_buffer;
 493   1              socket_ptr->send_len = strlen(html_buffer);
 494   1              // Return from the CGI script
 495   1              return;
 496   1              
 497   1      }
 498          
 499          //-----------------------------------------------------------------------------
 500          // establish_network_connection
 501          //-----------------------------------------------------------------------------
 502          //
 503          // This function calls mn_ether_init() to initialize the CP2200 and attach to
 504          // the network.
 505          //
 506          // If there is a network connection, the function returns 1.
 507          //
 508          // In the call to mn_ether_init(), NUM_AUTONEG_ATTEMPTS is set to 0, so the
 509          // function will not return until it successfully auto-negotiates.
 510          //
 511          // mn_ether_init() will not be a blocking call if NUM_AUTONEG_ATTEMPTS is set
 512          // to a value greater than 0.
 513          //
 514          int establish_network_connection()
 515          {
 516   1         int retval;
 517   1      
 518   1         do
 519   1         {
 520   2            // mn_ether_init() initializes the Ethernet controller.
 521   2            // AUTO_NEG indicates that the controller will auto-negotiate.
 522   2            retval = mn_ether_init(AUTO_NEG, 0, 0);
 523   2      
 524   2            // If there is no link, poll link_status until it sets or the
 525   2            // CP2200 resets and then call mn_ether_init() again.
 526   2            if (retval == LINK_FAIL)
 527   2            {
 528   3               while(!link_status && !ether_reset);
 529   3            }
 530   2      
 531   2            // If retval is less than zero and is not LINK_FAIL, there is a 
 532   2            // hardware error.
 533   2            else if (retval < 0)
 534   2            {
 535   3               // Verify that the Ethernet controller is connected and powered properly.
 536   3               // Verity that the EMIF has been configured at a speed compatible with the
 537   3               //    Ethernet controller.
 538   3               while(1);
 539   3            }
 540   2      
 541   2         }while(retval < 0);
 542   1      
 543   1         return (1);
 544   1      
 545   1      }
 546          
 547          
 548          //-----------------------------------------------------------------------------
C51 COMPILER V8.06   MAIN                                                                  05/02/2008 22:28:52 PAGE 10  

 549          // Initialization Routines
 550          //-----------------------------------------------------------------------------
 551          
 552          //-----------------------------------------------------------------------------
 553          // PORT_Init
 554          //-----------------------------------------------------------------------------
 555          //
 556          // Configure the Interrupts, Crossbar and GPIO ports
 557          //
 558          void PORT_Init (void)
 559          {
 560   1      
 561   1         IT01CF = 0x03;                      // Enable Interrupt 0 on P0.3
 562   1         TCON &= ~0x01;                      // Make /INT0 level triggered
 563   1      
 564   1         XBR0    = 0x01;                     // Enable UART on P0.4(TX) and P0.5(RX)
 565   1         XBR1    = 0xC0;                     // Enable crossbar and disable
 566   1                                             // weak pull-ups
 567   1      
 568   1         P0=0x48;
 569   1         P0MDOUT |= 0xB7;                    // enable UTX as push-pull output
 570   1         P1MDOUT |= 0xC0;                    // /WR and /RD are push-pull
 571   1                                             // AB4 LEDs are push-pull
 572   1         P2MDOUT |= 0xff;
 573   1         P3MDOUT |= 0xFF;
 574   1         P4MDOUT |= 0xFF;
 575   1         
 576   1         
 577   1      }
 578          
 579          //-----------------------------------------------------------------------------
 580          // EMIF_Init
 581          //-----------------------------------------------------------------------------
 582          //
 583          // Configure the External Memory Interface for both on and off-chip access.
 584          //
 585          void EMIF_Init (void)
 586          {
 587   1      
 588   1         EMI0CF = 0x1B;             // non-muxed mode; split mode
 589   1                                    // with bank select 0x1B, 17??
 590   1      
 591   1         EMI0TC = EMIF_TIMING;      // This constant may be modified
 592   1                                    // according to SYSCLK to meet the
 593   1                                    // timing requirements for the CP2200
 594   1      
 595   1         EMI0CN = 0x10;//BASE_ADDRESS;     // Page of XRAM accessed by EMIF
 596   1      
 597   1      }
 598          
 599          //-----------------------------------------------------------------------------
 600          // SYSCLK_Init
 601          //-----------------------------------------------------------------------------
 602          //
 603          // This routine initializes the system clock.
 604          //
 605          void SYSCLK_Init (void)
 606          {
 607   1         int i;
 608   1      
 609   1         OSCICN |= 0x03;                     // Configure internal oscillator for
 610   1                                             // its maximum frequency
C51 COMPILER V8.06   MAIN                                                                  05/02/2008 22:28:52 PAGE 11  

 611   1        
 612   1         CLKMUL = 0x00;                      // Reset Clock Multiplier and select
 613   1                                             // internal oscillator as input source
 614   1      
 615   1         CLKMUL |= 0x80;                     // Enable the Clock Multiplier
 616   1      
 617   1         for(i = 0; i < 256; i++);           // Delay at least 5us
 618   1         
 619   1         CLKMUL |= 0xC0;                     // Initialize the Clock Multiplier
 620   1         
 621   1         while(!(CLKMUL & 0x20));            // Wait for MULRDY => 1
 622   1         
 623   1         RSTSRC = 0x06;                      // Enable missing clock detector
 624   1                                             // and VDD monitor
 625   1         
 626   1         FLSCL |= 0x10;                      // Set Flash Scale for 48MHz
 627   1         
 628   1         CLKSEL |= 0x03;                     // Select output of clock multiplier
 629   1                                             // as the system clock.
 630   1      
 631   1      }
 632          
 633          //-----------------------------------------------------------------------------
 634          // ether_reset_low
 635          //-----------------------------------------------------------------------------
 636          //
 637          // This routine drives the reset pin of the ethernet controller low.
 638          //
 639          void ether_reset_low()
 640          {
 641   1      
 642   1         P1 &= ~0x01;               // Pull reset low
 643   1      
 644   1      }
 645          
 646          //-----------------------------------------------------------------------------
 647          // ether_reset_high
 648          //-----------------------------------------------------------------------------
 649          //
 650          // This routine places the reset pin in High-Z allowing it to be pulled up 
 651          // using the external pull-up resistor.
 652          //
 653          // Additionally, this routine waits for the reset pin to read high before
 654          // exiting.
 655          //
 656          void ether_reset_high (void)
 657          {
 658   1      
 659   1         P1 |= 0x01;               // Allow /RST to rise
 660   1         while(!(P1 & 0x01));      // Wait for /RST to go high
 661   1      
 662   1      
 663   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2982    ----
   CONSTANT SIZE    =    394    ----
   XDATA SIZE       =    301     333
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
C51 COMPILER V8.06   MAIN                                                                  05/02/2008 22:28:52 PAGE 12  

   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
